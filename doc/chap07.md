# 7장 C언어로 커널을 작성하자
## 7.1 실행 가능한 C 코드 커널 생성 방법
C 코드는 컴파일과 링크 과정을 거쳐 기계어로 번역된다.  
컴파일 과정은 소스파일을 오브젝트 파일로 변환하는 과정이다.
소스파일을 해석하여 코드 영역과 데이터 영역으로 나누고, 이러한 메모리 영역에 대한
정보를 생성하는 단계이다.  
링크 단계는 오브젝트 파일들의 정보를 취합하여 실행 파일에 통합하며, 필요한 라이브러리 등을 연결해 주는 역할을 하는 단계이다.

### 7.1.1 빌드 조건과 제약 사항
1. C 라이브러리를 사용하지 않게 빌드해야 한다.만약 코드에서 printf() 함수를 사용한다면, C 라이브러리를 동적 링크 똔느 정적 링크를 하게 되는데 이때 라이브러리가 포함되어 있지 않아서 정상적으로 실행되지 않는다.
2. 0x10200 위치에 실행하게끔 빌드해야한다. 0x10000의 위치에는 6장에서 작성한 1섹터 크기의 보호모드 엔트리 포인트가 있으므로, 결합된 C 코드는 512바이트 이후인 0x10200의 위치부터 로딩된다. 따라서 해당 위치에서 C 코드 중에 가장 먼저 실행되어야 하는 함수를 위치시켜야 한다. 커널이 메모리에 로딩되는 어드레스에 따라 전역 변수의 어드레스에 접근하는 주소가 변하기 때문이다. 
3. 코드나 데이터 외에 기타 정보를 포함하지 않은 순수한 바이너리 파일 형태여야 한다. 일반적인 gcc를 통해 실행파일을 생성하면 ELF 파일포맷이나 PE 파일 포맷과 같이 특정 OS에서 실행할 수 있는 포맷으로 생성된다. 해당 파일 포맷을 그대로 사용하게 되면 엔트리 포인트에서 파일 포맷을 해석하여 해당 정보에따라 처리하는 기능이 포함되어야 하므로 코드가 복잡해진다. 

### 7.1.2 소스 파일 컴파일 - 라이브러리를 사용하지 않는 오브젝트 파일 생성 방법
`-c` 옵션만 추가하면 오브젝트 파일까지 생성된다.  
라이브러리를 사용하지 않기 위해 `-ffreestanding`옵션을 지원한다.  
`-m32` 옵션은 32비트 코드 생성을 한다. 

### 7.1.3 오브젝트 파일 링크 - 라이브러리를 사용하지 않고 특정 어드레스에서 실행가능한 커널 이미지 파일 생성 방법
오브젝트 파일을 링크하여 실행 파일을 만드는 방법은 좀 까다롭다. 실행파일은 섹션의 배치, 로딩될 어드레스, 코드 내에서 가장 먼저 실행될 코드인 엔트리 포인트 등으로 구성되어 있다.
여기서는 섹션을 재배치 한다. 왜냐하면 실행 파일이 링크될 때 코드나 데이터 이외에 디벙긴 관련 정보와 심볼 정보 등 불필요한 정보가 포함되기 때문이다. 코드와 데이터 이외의 정보는 커널을 실행하는 데 직접적인 관련이 없기때문에 이를 제거하려고 섹션을 재배치 하는 것이다.

#### 섹션 배치와 링커 스크립트, 라이브러리를 사용하지 않는 링크
섹션은 실행 파일 또는 오브젝트 파일에 있으며 코드, 데이터, 각종 심볼, 디버깅 정보 등을 담는 영역을 뜻한다. 핵심 역할을 하는 섹션 3가지는 아래와 같다.
1. 실행 가능한 코드가 들어 있는 .text 섹션
2. 초기화 된 데이터가 들어 있는 .data 섹션
3. 초기화되지 않은 데이터가 들어 있는 .bss 섹션

소스코드를 컴파일 하여 생성한 오브젝트 파일은 각 섹션의 크기와 파일 내에 있는 오프셋 정보만 들어 있다. 왜냐하면, 오브젝트 파일은 중간 단계이고, 다른 오브젝트 파일과 합쳐지기 때문이다. 오브젝트 파일들을 결합하여 정리하고 실제 메모리에 로딩될 위치를 결정하는 것이 바로 링커이다.   
링커는 링커 스크립트를 참조하여 실행파일을 만든다. 링커 스크릅트에는 각 섹션의 배치 순서와 시작 어드레스, 섹션 크기 정렬 등의 정보를 저장해 놓은 텍스트 형태의 파일이다. 
```cmd
x86_64-pc-linux-ld.exe -melf_i386 -T elf_i386.x -nostdlib Main.o -o Main.elf
```

#### 로딩할 메모리 어드레스와 엔트리 포인트 지정
메모리에 로딩하는 어드레스를 지정하는 방법은 링커 스크립트를 수정하는 방법과 링커 프로그램의 명령줄 옵션으로 지정하는 방식 두 가지가 있다.
1. .text 0x10200 : { 생략 }
2. x86_64-pc-linux-ld.exe -Ttext 0x10200 Main.o -o Main.elf

엔트리 포인트 함수 역시 링커 스크립트 또는 커맨드 라인 옵션으로 호출할 수 있다. 여기서는 실행 파일을 바이너리로 변환하기 때문에 엔트리 포인트 정바고 제거되므로 큰 의미가 없다.  
바이너리파일에서 특정 함수를 실행 파일의 가장 앞쪽에 두려면 두 가지 순서를 조작해야한다.
1. 오브젝트 파일 내의 함수 간의 순서
2. 실행 파일 내의 함수 간의 순서

#### 실행 파일을 바이너리 파일로 변환
`objcopy` 프로그램을 통해 실행파일에서 불필요한 섹션을 제외하고 꼭 필요한 코드 섹션과 데이터 섹션만 추출할 수 있다. 

## 7.2 C 소스 파일 추가와 보호 모드 엔트리 포인트 통합
### 7.2.1 C 소스 파일 추가
[Main.c](/01.Kernel32/Source/Main.c) [Type.h](/01.Kernel32/Source/Types.h) 참고  
`#pragma pack`은 구조체의 크기 정렬에 관련된 지시어로 구조체의 크기를 1바이트로 정렬하여 추가적인 메모리 공간을 더 할당하지 않게 한다.

### 7.2.2 보호 모드 엔트리 포인트 코드 수정
/01.Kernel32/Source/EntryPoint.s 수정
보호모드 엔트리 포인트 이후에 C 커널 코드가 있으므로 무한 루프를 수행하는 코드를 0x10200으로 점프하게끔 변경한다. 

### 7.2.3 makefile 수정
C 커널 엔트리 포인트 함수를 가장 앞쪽에 배치하려면 에트리 포인트 오브젝트 파일을 맨 앞에 둬야 한다.  
컴파일된 어셈블리어 오브젝트 파일과 C 언어 오브젝트 파일은 같이 링크되어야 하므로 이를 고려하여 컴파일 옵션ㅇ르 설정해야 한다.  

## 7.3 커널 빌드와 실행
### 7.3.1 이미지 메이커 프로그램 작성
